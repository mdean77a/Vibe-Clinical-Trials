/**
 * Markdown Export utility for ICF documents
 * 
 * This module provides functionality to export ICF sections as markdown files
 * with proper formatting, metadata, and user-selectable save location.
 */

import type { ICFSectionData } from '../components/icf/ICFSection';
import type { Protocol } from '../types/protocol';

/**
 * Check if File System Access API is supported
 */
const isFileSystemAccessSupported = (): boolean => {
  return typeof window !== 'undefined' && 'showSaveFilePicker' in window;
};

/**
 * Get file handle using File System Access API (must be called during user gesture)
 */
const getFileHandleForSaving = async (defaultFilename: string) => {
  try {
    // @ts-ignore - File System Access API types may not be available
    const fileHandle = await window.showSaveFilePicker({
      suggestedName: defaultFilename,
      types: [
        {
          description: 'Markdown files',
          accept: {
            'text/markdown': ['.md'],
            'text/plain': ['.txt'],
          },
        },
      ],
    });
    return fileHandle;
  } catch (error) {
    if ((error as Error).name === 'AbortError') {
      throw new Error('File save cancelled by user');
    }
    throw error;
  }
};

/**
 * Save markdown to file handle
 */
const saveMarkdownToFileHandle = async (markdownContent: string, fileHandle: any): Promise<void> => {
  try {
    const writable = await fileHandle.createWritable();
    await writable.write(markdownContent);
    await writable.close();
    
    console.log(`Markdown file saved successfully to user-selected location`);
  } catch (error) {
    console.error('Error writing to file:', error);
    throw new Error('Failed to write markdown file to selected location');
  }
};

/**
 * Save markdown using traditional download (fallback method)
 */
const saveMarkdownWithDownload = (markdownContent: string, filename: string): void => {
  const blob = new Blob([markdownContent], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up
  URL.revokeObjectURL(url);
  
  console.log(`Markdown file downloaded to default location: ${filename}`);
};

/**
 * Generate markdown content from ICF sections
 */
const createMarkdownContent = (sections: ICFSectionData[], protocol: Protocol): string => {
  // Filter sections to include only completed ones
  const completedSections = sections.filter(
    section => section.status === 'ready_for_review' || section.status === 'approved'
  );

  const markdownParts = [
    // Front matter
    '# Informed Consent Form',
    '',
    `**Study:** ${protocol.study_acronym}`,
    `**Title:** ${protocol.protocol_title}`,
    `**Generated:** ${new Date().toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long', 
      day: 'numeric'
    })}`,
    `**Source:** Clinical Trial Accelerator - AI-Generated Document`,
    '',
    '---',
    '',
    
    // Table of Contents
    '## Table of Contents',
    '',
    ...completedSections.map((section, index) => 
      `${index + 1}. [${section.title}](#${section.title.toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '-')})`
    ),
    '',
    '---',
    '',
  ];

  // Add ICF sections
  completedSections.forEach((section, index) => {
    markdownParts.push(
      `## ${index + 1}. ${section.title}`,
      '',
      section.content,
      '',
      '---',
      '',
      `**Section Metadata:**`,
      `- Status: ${section.status === 'approved' ? 'Approved' : 'Ready for Review'}`,
      `- Word Count: ${section.wordCount || 0}`,
      `- Section ID: ${section.name}`,
      '',
      '---',
      ''
    );
  });

  // Add footer
  markdownParts.push(
    '## Document Information',
    '',
    `- **Study Acronym:** ${protocol.study_acronym}`,
    `- **Protocol Title:** ${protocol.protocol_title}`,
    `- **Total Sections:** ${completedSections.length}`,
    `- **Approved Sections:** ${completedSections.filter(s => s.status === 'approved').length}`,
    `- **Total Words:** ${completedSections.reduce((sum, s) => sum + (s.wordCount || 0), 0)}`,
    `- **Export Date:** ${new Date().toISOString()}`,
    `- **Export Format:** Markdown`,
    `- **Generated By:** Clinical Trial Accelerator AI`,
    '',
    '---',
    '',
    '*This document was generated using the Clinical Trial Accelerator platform.*'
  );

  return markdownParts.join('\n');
};

/**
 * Generate and save ICF markdown with user-selectable location
 */
export const generateICFMarkdown = async (
  sections: ICFSectionData[], 
  protocol: Protocol,
  options: {
    includeAllSections?: boolean;
    filename?: string;
    useFilePicker?: boolean;
  } = {}
): Promise<void> => {
  try {
    // Filter sections based on options
    const sectionsToInclude = options.includeAllSections 
      ? sections 
      : sections.filter(s => s.status === 'ready_for_review' || s.status === 'approved');

    if (sectionsToInclude.length === 0) {
      throw new Error('No sections available for markdown generation. Please generate or approve sections first.');
    }

    // Generate filename
    const timestamp = new Date().toISOString().split('T')[0];
    const defaultFilename = options.filename || `${protocol.study_acronym}_ICF_${timestamp}.md`;
    
    // Determine save method and get file handle first if using file picker
    const useFilePicker = options.useFilePicker !== false && isFileSystemAccessSupported();
    let fileHandle: any = null;
    
    if (useFilePicker) {
      // Get file handle first (during user gesture) before generating content
      fileHandle = await getFileHandleForSaving(defaultFilename);
    }

    // Generate markdown content
    const markdownContent = createMarkdownContent(sectionsToInclude, protocol);
    
    if (fileHandle) {
      // Save to user-selected location
      await saveMarkdownToFileHandle(markdownContent, fileHandle);
    } else {
      // Fallback to traditional download
      saveMarkdownWithDownload(markdownContent, defaultFilename);
    }
    
  } catch (error) {
    console.error('Error generating markdown:', error);
    throw error;
  }
};

/**
 * Validate sections for markdown generation
 */
export const validateSectionsForMarkdown = (sections: ICFSectionData[]): {
  isValid: boolean;
  message: string;
  warnings: string[];
} => {
  const completedSections = sections.filter(
    s => s.status === 'ready_for_review' || s.status === 'approved'
  );
  
  if (completedSections.length === 0) {
    return {
      isValid: false,
      message: 'No sections are ready for markdown generation. Please generate or approve sections first.',
      warnings: []
    };
  }
  
  const warnings: string[] = [];
  
  // Check for empty content
  const emptySections = completedSections.filter(s => !s.content.trim());
  if (emptySections.length > 0) {
    warnings.push(`${emptySections.length} sections have empty content`);
  }
  
  // Check for very short sections
  const shortSections = completedSections.filter(s => (s.wordCount || 0) < 10);
  if (shortSections.length > 0) {
    warnings.push(`${shortSections.length} sections have very short content (< 10 words)`);
  }
  
  // Check if not all sections are approved
  const unapprovedSections = completedSections.filter(s => s.status !== 'approved');
  if (unapprovedSections.length > 0) {
    warnings.push(`${unapprovedSections.length} sections are not yet approved`);
  }
  
  return {
    isValid: true,
    message: `Ready to generate markdown with ${completedSections.length} sections`,
    warnings
  };
};

/**
 * Get file system capabilities for markdown files
 */
export const getMarkdownFileSystemCapabilities = () => {
  const hasFileSystemAccess = isFileSystemAccessSupported();
  
  return {
    hasFileSystemAccess,
    saveMethod: hasFileSystemAccess ? 'file-picker' : 'download',
    description: hasFileSystemAccess 
      ? 'Browser supports choosing save location'
      : 'Browser will download to default Downloads folder'
  };
};

/**
 * Preview markdown content without saving
 */
export const previewMarkdownContent = (sections: ICFSectionData[], protocol: Protocol): string => {
  const completedSections = sections.filter(
    s => s.status === 'ready_for_review' || s.status === 'approved'
  );
  
  if (completedSections.length === 0) {
    return '# No sections available for preview\n\nPlease generate or approve sections first.';
  }
  
  return createMarkdownContent(completedSections, protocol);
};